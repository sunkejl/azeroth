#不同 GC 和堆内存的总结


1. 串行 GC
2. 并行 GC
3. cms GC
4. G1 GC


## 串行GC
串行GC是jvm里最简单最原始的垃圾回收策略
年轻代使用标记-复制(mark-copy) 老年代使用标记-清除-整理(mark-sweep-compact)
是单线程的垃圾收集器 不能并行处理，会触发STW



## 并行GC
并行GC是jdk 678的默认GC
年轻代使用标记-复制(mark-copy) 老年代使用标记-清除-整理(mark-sweep-compact)
在这些版本中 没有显式的指定GC 启动用的都是并行GC
并行GC默认使用跟cpu核心数数量想的线程来做GC
目的是最大化的增加整个系统的业务处理吞吐量


# CMS GC
年轻代使用并行的标记-复制(mark-copy) 老年代使用并发标记-清除(mark-sweep)
CMS GC的目的是避免老年代垃圾回收出现长时间的卡顿
CMS GC与并行GC的比较
相同点：
都是多线程
区别:
parallelGC会使用所有的CPU的核心线程数
CMS GC做垃圾回收的线程和业务线程大多数情况可以同时运行




## G1 GC
garbage first GC
jdk 9以及以后的版本 默认的GC是G1
垃圾优先，哪一块有垃圾 优先清理它
目的: 将STW停顿的时间和分布变成可预期且可配置的
对内存整体划分
在回收时评估每个小堆块存活对象的总数
垃圾最多的小块会优先收集



---
## 引用
以打扫卫生为例，一层楼有很多工作人员在工作，现在需要打扫卫生。

1、串行GC：所有人都出去，一个保洁阿姨来打扫卫生，
打扫完了，大家再进来工作。

2、并行GC：所有人都出来，一大群保洁阿姨来打扫卫生，
打扫完了，大家再进来工作。

3、CMS：每次1/4的人出去，进来三五个阿姨打扫卫生，
然后还有3/4的工作人员在干活，
所以能够做到业务大部分时候不会被GC暂停
（只需要在开始清点垃圾和确认垃圾的时候需要所有人暂停一小下）。
但是明显的是，干活的阿姨变少了，所以整体处理效率实际上降低了。

4、G1：在CMS的基础上，把整个楼层的工位区域分成很多小片，
每次处理其中的一部分片，
所以可以更加精细化管理了，
对每次作业的估计可以更加精确了，
每次也是少量几个阿姨来打扫，所以效率其实也不会比Parallel高。